	Learning2DEngine (namespace)
		System (namespace)
			Component
				Source code: 
				Description:
				Fistly, it looks a bad structure, because there is a cross reference. A Component has reference about its GameObject and the GameObject has 
				reference about that Component. But if the developer follow some rules, everything will be alright.
				The classes, which are inherited from Component, have to have a constructor, which first parameter is GameObject* for gameObject member.
				Moreover, It is recommended, that the constructor, the Init() and Destroy() of the inherited class is protected
				and only the GameObject can use them.
				If the developer follow this, only the GameObject can create/initialize/destroy Components, so a Component can't exist without its GameObject.
				Furthermore, the Components have reference about their gameobject, so this gave the developer a huge flexibility.
				They can give or get components from the their GameObject within a Component.
				Please check the System::GameObject too.
				Variables:
					Public:
					GameObject* const gameObject;
				Functions:
					Protected:
					virtual void Init();
					It initializes the Component.
					virtual void Destroy();
					It destroys the Component.
					Public:
					inline void SetActive(bool value);
					It changes the isActive.
					inline bool GetActive();
					It returns true, if the isActive is true.
			Game
				Source code:
				Description:
				The System::Game class is, which holds everything together in the Engine.
				If a developer want to create a game by this Engine, that game must be inherited from this System::Game class.
				The Function order in the Run() (in a frame):
					1. Calculate deltaTime
					2. Refresh Keyboard and Mouse events
					3. virtual Update()
					4. Clear Window to default color
					5. virtual Render() (Render with MSAA and PostProcessEffect, if they are enabled)
					6. virtual LateRender (Render without any effect
					7. Update Window
				Macrok:
					INPUT_KEY_SIZE 1024
					TIME_SCALE_DEFAULT 1.0f
				Variables:
					Private:
					static float deltaTime;
					It is multiplied by timeScale. Before the Game::Run(), it is 0.0f.
					
					Protected:
					InputStatus inputKeys[INPUT_KEY_SIZE];
					This array contains, which button is up, down or hold.
					The developer should not write this array, just read it.
					
					static glm::mat4 cameraProjection;
					The camera projecttion, which used by the shaders. The developer can modify, what the player can see.
					It has to be initialized. It is glm::mat4(0.0f) by default.
					
					static Render::Resolution cameraResolution;
					It has to be initialized, because the camera resolution don't have to be same with game resolution.
					It is (0,0) by default. The developer can use it as a constant grid size, if they do not change it.
					For example: the default (game) screen and camera resolution is 800x600 and there is a text in the middle of the Game Window.
					If the player change the resolution of the game, the camera resolution won't change, so the text will stay in the middle of the Game Window.
				Functions:
					Protected:
					virtual void Update();
					It is recommended, that this function should contain every update in the game, which is not rendering.
					virtual void Render();
					It is recommended, that this function should contain every rendering functions, which render the game scene.
					It uses the MSAA and PostProcessEffect, if they are enabled. But there are some exception, please check the Game::LateRender().
					virtual void LateRender();
					It is also a rendering function. But this does not use the the MSAA and PostProcessEffect.
					This can be useful for UI.
					
					Public:
					void InitWithRender(int majorRenderVersion, int minorRenderVersion, Render::Resolution resolution, const char* title, bool resizableWindows = true);
					It initializes the RenderManager. After that, the Init() will be called.
					virtual void Init();
					It initializes the Game, but the RenderManager have to be initialized before this.
					If this function is override, it must call the Game::Init() in the first line.
					The Blend is enable by default with Source: SRC_ALPHA, Destination: ONE_MINUS_SRC_ALPHA, because it is used for some features.
					virtual void Terminate();
					It terminates the Game.
					If this function is override, it must call the Game::Terminate() in the last line.
					void Run();
					It runs the Game.
					It has an infinite loop, that's why it will run until the game window is closed.
					Please check the Game's Description for the function order.
					void RefreshKeyboardMouse(int key, int scancode, int action, int mode) override;
					The developer should not use this function. The Game subscribe for button events and the RenderManager call this function by an event.
					virtual void RefreshResolution(const Learning2DEngine::Render::Resolution& resolution) override;
					The developer should not use this function. The Game subscribe for (game) screen resolution events and the RenderManager call this function by an event.
					
					void ActivateMSAA(unsigned int sampleNumber);
					It activates the MSAA.
					void StopMSAA();
					It stops the MSAA.
					inline bool IsMsaaActive();
					It returns true, if the MSAA is activated.
					
					void ActivatePostProcessEffect();
					It activates the PostProcessEffect. By default, it renders the game screen without any modification.
					void StopPostProcessEffect();
					It stops the PostProcessEffect.
					inline bool IsPostProcessEffectActive();
					It returns true, if the PostProcessEffect is activated.
					
					void UsePostProcessEffect(const Render::Shader& shader);
					It start to use the new effect shader for post processing.
					inline void UsePostProcessEffect();
					It start to use its effect shader for post processing.
					inline void NotUsePostProcessEffect()
					It start to use the default shader (it renders the game screen without any modification).
					But the effect shader still exist.
					void ClearPostProcessEffect();
					It start to use the default shader (it renders the game screen without any modification).
					And delete the effect shader.
					inline bool IsPostProcessEffectUsed();
					It returns true, if the effect shader is used.
					
					inline void ResetTimeScale();
					It resets the timeScale by default (TIME_SCALE_DEFAULT).
					inline void SetTimeScale(float value);
					It sets the timeScale.
					inline float GetTimeScale();
					It returns the timeScale.
					static float GetDeltaTime();
					It returns the deltaTime.
					Please check more info about Game::deltaTime.
					static glm::mat4 GetCameraProjection();
					It returns the cameraProjection.
					static Render::Resolution GetCameraResolution();
					It returns the cameraResolution.
					void SetCameraResolution(const Learning2DEngine::Render::Resolution& resolution);
					It sets the cameraResolution and the cameraProjection too.
			GameObject
				Source code: 
				Description:
				The GameObject represent the objects in the game.
				It can contain the components, which give a big flexibility.
				Please check the System::Component too.
				Variables:
					Private:
					std::vector<Component*> components;
					Public:
					bool isActive;
					Transform transform;
				Functions:
					Public:
					~GameObject();
					It calls Destroy() function of the current gameobject's components and delete them.
					
					template <class TComponent, class ...Params>
					TComponent* AddComponent(Params... params);
					It adds a component to the gameobject and it calls the Init() function of the component.
					This is a really flexible function. The developer can add parameters to component's constructor.
					For example:
						A Component constructor: PlayerController(GameObject* gameObject, const std::string& textureId);
						The textureId can be added by this format:
						GameObject* player = new GameObject();
						playerController = player->AddComponent<PlayerController, const std::string&>("paddle");
					
					template <class TComponent>
					TComponent* GetComponent();
					template <class TComponent>
					const TComponent* GetComponent() const;
					They return the component, whose class is TComponent.
					If the gameobject does not have this component, it will return NULL.
					
					template <class TComponent>
					std::vector<TComponent*> GetComponents();
					It returns all components, whose class is TComponent.
					If the gameobject does not have these components, it will return an empty vector.
					
					static void Destroy(GameObject* gameObject);
					It destroys the gameobject.
					
					static void Destroy(Component* component);
					It destroys the gameobject of the component.
					That's why this component and all other components, which the gameobject has, will be destroyed.
					
			IKeyboardMouseRefresher
				Source code: 
				Description:
				Description:
				It is a little interface, which the developer can use to wrap a class into KeyboardMouseEventItem.
				Functions:
					Public:
					virtual void RefreshKeyboardMouse(int key, int scancode, int action, int mode) = 0;
			InputStatus
				Source code: 
				Description:
				It is an enam class, which contains the 3 phase of the buttons.
				KEY_UP: The key or mouse button was released.
				KEY_DOWN: The key or mouse button was pressed.
				KEY_HOLD: The key was held down until it repeated.
			Random
				Source code: 
				Description:
				It is a static random number generator.
				It uses the rand() function from cstdlib. So, the randomness is depend on RAND_MAX.
				If the isInited is false, the next GetNumber function will run the std::srand(std::time(nullptr)), before generation.
				Variables:
					Public:
					static bool isInited;
				Functions:
					Public:
					static int GetNumber(int minInclusive, int maxExclusive);
					Return a random int within [minInclusive..maxExclusive)
					static float GetNumber(float minInclusive, float maxInclusive);
					Return a random float within [minInclusive..maxInclusive]
			ResourceManager
				Source code: 
				Description:
				It is really recommended, that the developer create shaders and textures with the ResourceManager, that
				they can avoid the useless allocation and memory leak. The exception should be minimum.
				It use one-one std::map for shaders and textures, where the id is their name.
				Functions:
					Public:
					Shader LoadShaderFromFile(const std::string& name, const char* vertexFilePath, const char* fragmentFilePath, const char* geometryFilePath = nullptr);
					It creates a shader from files.
					Shader LoadShader(const std::string& name, const char* vertexText, const char* fragmentText, const char* geometryText = nullptr);
					It creates a shader from strings.
					Shader GetShader(const std::string& name);
					It returns a shader. If the shader does not exist, it will return an uninitialized shader.
					It is recommended to use the IsShaderExist.
					bool IsShaderExist(const std::string& name);
					It returns true if the shader exist.
					void DestroyShader(const std::string& name);
					It destroys the shader.

					Texture2D LoadTextureFromFile(const std::string& name, const char* filePath, const Render::Texture2DSettings& settings);
					It creates a texture from files.
					Texture2D GetTexture(const std::string& name);
					It returns a texture. If the texture does not exist, it will return an uninitialized texture.
					It is recommended to use the IsTextureExist.
					bool IsTextureExist(const std::string& name);
					It returns true if the texture exist.
					void DestroyTexture2D(const std::string& name);
					It destroys the texture.
					
					void Clear();
					It destroys all shaders and textures.
			Singleton
				Source code: 
				Description:
				A base singleton abstarct class.
				It is recommended, that the constructor of inherited class is private or protected and
				The Singleton is a friend class.
				Functions:
					Public:
					static T& GetInstance();
					It returns the instance.
			Transform
				Source code: 
				Description:
				It contains the position the scale and the rotation. Every gameobject has a transform.
				Variables:
					Public:
					glm::vec2 position;
					glm::vec2 scale;
					float rotation;