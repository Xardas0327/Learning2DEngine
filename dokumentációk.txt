	Learning2DEngine (namespace)
		Render (namespace)
			BlendFuncFactor
				Source code:
				Description:
				It is a pair, where the developer have to use the the OpenGL Blend's constants.
				First is the source factor. Second is the destination factor.
			IResolutionRefresher
				Source code:
				Description:
				It is a little interface, which the developer can use to wrap a class into ResolutionEventItem.
				Functions:
					Public:
					virtual void RefreshResolution(const Resolution& resolution) = 0;
			MSAA
				Source code:
				Description:
				Multisample anti-aliasing for rendering.
				Functions:
					Public:
					void Init(unsigned int sampleNumber, Resolution resolution);
					It initializes the MSAA and its frame buffer.
					
					void Destroy();
					It destroys the MSAA.
					
					void StartRender(bool useClear = true);
					It binds the MSAA Frame Buffer. Plus it clears the buffer if the useClear is true.
					
					void EndRender(unsigned int resultFbo, Resolution  resultResolution);
					It copies the MSAA buffer data to result framebuffer and it convert the MSAA resolution to result resolution.
					
					inline unsigned int GetId();
					It returns the frame buffor object id.
					
					inline unsigned int GetSampleNumber();
					It returns the sample number.
				
			PostProcessEffect
				Source code:
				Description:
				Post Process Effect for rendering.
				Functions:
					Public:
					void Init(Resolution resolution);
					It initializes PostProcessEffect and its frame buffer and texture.
					
					void Destroy();
					It destroys the PostProcessEffect.
					
					void StartRender(bool useClear = true);
					It binds the PostProcessEffect Frame Buffer. Plus it clears the buffer if the useClear is true.
					
					void EndRender();
					It binds the default Frame Buffer.
					
					void Render();
					It renders the PostProcessEffect texture.
					
					void SetShader(const Shader& shader);
					It changes the PostProcessEffect's shader to another shader.
					
					void ClearShader();
					It changes back the PostProcessEffect's shader to default.
				
			Renderer
				Source code:
				Description:
				This is an abstract component class for the rendering.
				The classes, which are inherited from this Renderer, have to have a constructor, which first parameter is GameObject* for gameObject member.
				Please check more info about System::Component.
				Functions:
					Public:
					virtual void Draw() = 0;
					It should be called in the current game's Render();
			RenderManager
				Source code:
				Description:
				This is the heart of the rendering in the Engine. The developer can initialize the OpenGL and set or change its variables.
				Functions:
					Public:
					void Init(int majorVersion, int minorVersion, Resolution resolution, const char* title, bool resizableWindows = true);
					It initializes RenderManager.
					
					void Terminate();
					It terminates the RenderManager.
					
					void CloseWindow();
					It closes the (game) screen window.
					bool IsWindowClosed();
					It returns true, the the (game) screen window is closed.
					void SetVSync(bool value);
					It turn on/off the VSync.
					void UpdateWindow();
					It updates (game) screen window (swap the buffers).
					void ClearWindow();
					It clears the color buffer by the clearColor variable.
					inline Resolution GetResolution();
					It returns the (game) screen resolution.
					void SetClearColor(float r, float g, float b, float a);
					It sets the clearColor for ClearWindow();
					inline glm::vec4 GetClearColor();
					It returns the current clearColor.
					void EnableBlend();
					It enables the blend.
					void DisableBlend();
					It disables the blend.
					inline bool IsBlendActive();
					It returns true if the blend is enabled.
					void SetBlendFunc(unsigned int sourceFactor, unsigned int destinationFactor);
					void SetBlendFunc(BlendFuncFactor blendFuncFactor);
					It sets the BlendFunc.
					inline BlendFuncFactor GetBlendFunc();
					It returns the current BlendFuncFactor.
					void AddKeyboardEvent(EventSystem::EventItem<int, int, int, int>* evenItem);
					It adds event to Keyboard and Mouse events.
					void RemoveKeyboardEvent(EventSystem::EventItem<int, int, int, int>* evenItem);
					It removes event to Keyboard and Mouse events.
					void AddFramebufferSizeEvent(EventSystem::EventItem<Resolution>* evenItem);
					It adds event to Resolution changing events.
					void RemoveFramebufferSizeEvent(EventSystem::EventItem<Resolution>* evenItem);
					It removes event to Resolution changing events.
			Resolution
				Source code:
				Description:
				Resolution class.
			Shader
				Source code:
				Description:
				The OpenGL Shader representation in the Engine.
				Functions:
					Public:
					void Create(const char* vertexSource, const char* fragmentSource, const char* geometrySource = nullptr);
					It creates the shader.
					void Destroy();
					It destroys the shader.
					void Use() const;
					It binds the shader.
					inline unsigned int GetId();
					It returns the id of shader.
					void SetFloat(const char* name, float value);
					void SetInteger(const char* name, int value);
					void SetVector2f(const char* name, float x, float y);
					void SetVector2f(const char* name, const glm::vec2& value);
					void SetVector3f(const char* name, float x, float y, float z);
					void SetVector3f(const char* name, const glm::vec3& value);
					void SetVector4f(const char* name, float x, float y, float z, float w);
					void SetVector4f(const char* name, const glm::vec4& value);
					void SetMatrix4(const char* name, const glm::mat4& matrix);
					void SetArray1f(const char* name, float* value, unsigned int length);
					void SetArray1i(const char* name, int* value, unsigned int length);
					void SetArray2f(const char* name, float* value, unsigned int length);
					void SetArray2i(const char* name, int* value, unsigned int length);
					There are a lof of functions to update the shader parameters.
			ShaderConstant
				Source code:
				Description:
				The basic shaders of the Engine are in variables and not in files.
				Variables:
					Public:
					static const std::string SPRITE_SHADER_NAME;
					static const char* const SPRITE_VERTEX_SHADER;
					static const char* const SPRITE_FRAGMENT_SHADER;
					The sprite shader's name (for ResourceManager), vertex and fragment shaders.

					static const std::string TEXT2D_SHADER_NAME;
					static const char* const TEXT2D_VERTEX_SHADER;
					static const char* const TEXT2D_FRAGMENT_SHADER;
					The Text2D shader's name (for ResourceManager), vertex and fragment shaders.

					static const std::string DEFAULT_POSTPROCESS_EFFECT_NAME;
					static const char* const DEFAULT_POSTPROCESS_EFFECT_VERTEX_SHADER;
					static const char* const DEFAULT_POSTPROCESS_EFFECT_FRAGMENT_SHADER;
					The default PostProcessEffect shader's name (for ResourceManager), vertex and fragment shaders.
			SpriteRenderer
				Source code:
				Description:
				The SpriteRenderer is for the GameObjects.
				It uses static variables to count how many GameObject initialized it.
				So it will destroy its Vertex Array Object only if the reference number is 0, otherway it will decrease the reference number only.
				Variables:
					Public:
					Texture2D* texture;
					The texture, which the SpriteRenderer will use.
					This can be useful if the developer want to change anything in the texture.
					But if the developer want to remove it, they should use the ClearTexture() function.
					glm::vec3 color;
					The color, which will be mixed with the texture in the shader.
				Functions:
					Private:
					void Init();
					It initializes the SpriteRenderer.
					void Destroy();
					It destroys the SpriteRenderer.
					Public:
					~SpriteRenderer();
					It will delete the texture pointer.
					void Draw();
					It draws the sprite;
					Please check the Render::Renderer documentation too.
					inline bool IsUseTexture();
					It returns true, if SpriteRenderer has texture.
					inline void ClearTexture();
					It deletes the texture pointer.
			Texture2D
				Source code:
				Description:
				The OpenGL Texture2D representation in the Engine.
				If the developer changes any variables in it, it will be used only after Create function.
				Functions:
					Public:
					void Create(unsigned int width, unsigned int height, const unsigned char* data);
					it creates the Texture2D.
					void Destroy();
					it destroys the Texture2D.
					void Bind() const;
					It binds the Texture2D.
					inline unsigned int GetId();
					It returns the id of the Texture2D.
			Texture2DSettings
				Source code:
				Description:
				It is a collection of setting parameters for Texture2D.
				It uses OpenGL constants like GL_RGB, GL_REPEAT, GL_LINEAR etc.
			
		System (namespace)
			Component
				Source code: 
				Description:
				Fistly, it looks a bad structure, because there is a circle. A Component has reference about its GameObject and the GameObject has 
				reference about that Component. But if the developer follow this rule, everything will be alright.
				The classes, which are inherited from Component, have to have a constructor, which first parameter is GameObject* for gameObject member.
				Moreover, It is recommended, that the constructor, the Init() and Destroy() of the inherited class is protected
				and only the GameObject can use them.
				If the developer follow this, only the GameObject can create/init/destroy Components, so a Component can't exist without its GameObject.
				Furthermore, the Components have reference about their gameobject, so this gave the developer a huge flexibility.
				They can give or get components from the their GameObject within a Component.
				Please check the System::GameObject too.
				Variables:
					Public:
					GameObject* const gameObject;
				Functions:
					Protected:
					virtual void Init();
					It initializes the Component.
					virtual void Destroy();
					It destroys the Component.
					Public:
					inline void SetActive(bool value);
					It changes the isActive.
					inline bool GetActive();
					It returns true, if the isActive is true.
			Game
				Source code:
				Description:
				The System::Game class is, which holds everything together in the Engine.
				If a developer want to create a game by this Engine, that game must be inherited from this System::Game class.
				The Function order in the Run() (in a frame):
					1. Calculate deltaTime
					2. Refresh Keyboard and Mouse events
					3. virtual Update()
					4. Clear Window to default color
					5. virtual Render() (Render with MSAA and PostProcessEffect, if they are enabled)
					6. virtual LateRender (Render without any effect
					7. Update Window
				Macrok:
					INPUT_KEY_SIZE 1024
					TIME_SCALE_DEFAULT 1.0f
				Variables:
					Private:
					static float deltaTime;
					It is multiplied by timeScale. Before the Game::Run(), it is 0.0f.
					
					Protected:
					InputStatus inputKeys[INPUT_KEY_SIZE];
					This array contains, which button is up, down or hold.
					The developer should not write this array, just read it.
					
					static glm::mat4 cameraProjection;
					The camera projecttion, which used by the shaders. The developer can modify, what the player can see.
					It has to be initialized. It is glm::mat4(0.0f) by default.
					
					static Render::Resolution cameraResolution;
					It has to be initialized, because the camera resolution don't have to be same with game resolution.
					It is (0,0) by default. The developer can use it as a constant grid size, if they do not change it.
					For example: the default (game) screen and camera resolution is 800x600 and there is a text in the middle of the Game Window.
					If the player change the resolution of the game, the camera resolution won't change, so the text will stay in the middle of the Game Window.
				Functions:
					Protected:
					virtual void Update();
					It is recommended, that this function should contain every update in the game, which is not rendering.
					virtual void Render();
					It is recommended, that this function should contain every rendering functions, which render the game scene.
					It uses the MSAA and PostProcessEffect, if they are enabled. But there are some exception, please check the Game::LateRender().
					virtual void LateRender();
					It is also a rendering function. But this does not use the the MSAA and PostProcessEffect.
					This can be useful for UI.
					Public:
					void InitWithRender(int majorRenderVersion, int minorRenderVersion, Render::Resolution resolution, const char* title, bool resizableWindows = true);
					It initializes the RenderManager. After that, the Init() will be called.
					virtual void Init();
					It initializes the Game, but the RenderManager have to be initialized before this.
					If this function is override, it must call the Game::Init() in the first line.
					The Blend is enable by default with Source: SRC_ALPHA, Destination: ONE_MINUS_SRC_ALPHA, because it is used for some features.
					virtual void Terminate();
					It terminates the Game.
					If this function is override, it must call the Game::Terminate() in the last line.
					void Run();
					It runs the Game.
					It has an infinite loop, that's why it will run until the game window is closed.
					Please check the Game's Description for the function order.
					void RefreshKeyboardMouse(int key, int scancode, int action, int mode) override;
					The developer should not use this function. The Game subscribe for button events and the RenderManager call this function by an event.
					virtual void RefreshResolution(const Learning2DEngine::Render::Resolution& resolution) override;
					The developer should not use this function. The Game subscribe for (game) screen resolution events and the RenderManager call this function by an event.
					
					void ActivateMSAA(unsigned int sampleNumber);
					It activates the MSAA.
					void StopMSAA();
					It stops the MSAA.
					inline bool IsMsaaActive();
					It returns true, if the MSAA is activated.
					
					void ActivatePostProcessEffect();
					It activates the PostProcessEffect. By default, it renders the game screen without any modification.
					void StopPostProcessEffect();
					It stops the PostProcessEffect.
					inline bool IsPostProcessEffectActive();
					It returns true, if the PostProcessEffect is activated.
					
					void UsePostProcessEffect(const Render::Shader& shader);
					It start to use the new effect shader for post processing.
					inline void UsePostProcessEffect();
					It start to use its effect shader for post processing.
					inline void NotUsePostProcessEffect()
					It start to use the default shader (it renders the game screen without any modification).
					But the effect shader still exist.
					void ClearPostProcessEffect();
					It start to use the default shader (it renders the game screen without any modification).
					And delete the effect shader.
					inline bool IsPostProcessEffectUsed();
					It returns true, if the effect shader is used.
					
					inline void ResetTimeScale();
					It resets the timeScale by default (TIME_SCALE_DEFAULT).
					inline void SetTimeScale(float value);
					It sets the timeScale.
					inline float GetTimeScale();
					It returns the timeScale.
					static float GetDeltaTime();
					It returns the deltaTime.
					Please check more info about Game::deltaTime.
					static glm::mat4 GetCameraProjection();
					It returns the cameraProjection.
					static Render::Resolution GetCameraResolution();
					It returns the cameraResolution.
					void SetCameraResolution(const Learning2DEngine::Render::Resolution& resolution);
					It sets the cameraResolution and the cameraProjection too.
			GameObject
				Source code: 
				Description:
				The GameObject represent the objects in the game.
				It can contain the components, which give a big flexibility.
				Please check the System::Component too.
				Variables:
					Private:
					std::vector<Component*> components;
					Public:
					bool isActive;
					Transform transform;
				Functions:
					Public:
					~GameObject();
					It calls Destroy() function of the current gameobject's components and delete them.
					
					template <class TComponent, class ...Params>
					TComponent* AddComponent(Params... params);
					It adds a component to the gameobject and it calls the Init() function of the component.
					This is a really flexible function. The developer can add parameters to component's constructor.
					For example:
						A Component constructor: PlayerController(GameObject* gameObject, const std::string& textureId);
						The textureId can be added by this format:
						GameObject* player = new GameObject();
						playerController = player->AddComponent<PlayerController, const std::string&>("paddle");
					
					template <class TComponent>
					TComponent* GetComponent();
					template <class TComponent>
					const TComponent* GetComponent() const;
					They return the component, whose class is TComponent.
					If the gameobject does not have this component, it will return NULL.
					
					template <class TComponent>
					std::vector<TComponent*> GetComponents();
					It returns all components, whose class is TComponent.
					If the gameobject does not have these components, it will return an empty vector.
					
					static void Destroy(GameObject* gameObject);
					It destroys the gameobject.
					
					static void Destroy(Component* component);
					It destroys the gameobject of the component.
					That's why this component and all other components, which the gameobject has, will be destroyed.
					
			IKeyboardMouseRefresher
				Source code: 
				Description:
				Description:
				It is a little interface, which the developer can use to wrap a class into KeyboardMouseEventItem.
				Functions:
					Public:
					virtual void RefreshKeyboardMouse(int key, int scancode, int action, int mode) = 0;
			InputStatus
				Source code: 
				Description:
				It is an enam class, which contains the 3 phase of the buttons.
				KEY_UP: The key or mouse button was released.
				KEY_DOWN: The key or mouse button was pressed.
				KEY_HOLD: The key was held down until it repeated.
			Random
				Source code: 
				Description:
				It is a static random number generator.
				It uses the rand() function from cstdlib. So, the randomness is depend on RAND_MAX.
				If the isInited is false, the next GetNumber function will run the std::srand(std::time(nullptr)), before generation.
				Variables:
					Public:
					static bool isInited;
				Functions:
					Public:
					static int GetNumber(int minInclusive, int maxExclusive);
					Return a random int within [minInclusive..maxExclusive)
					static float GetNumber(float minInclusive, float maxInclusive);
					Return a random float within [minInclusive..maxInclusive]
			ResourceManager
				Source code: 
				Description:
				It is really recommended, that the developer create shaders and textures with the ResourceManager, that
				they can avoid the useless allocation and memory leak. The exception should be minimum.
				It use one-one std::map for shaders and textures, where the id is their name.
				Functions:
					Public:
					Shader LoadShaderFromFile(const std::string& name, const char* vertexFilePath, const char* fragmentFilePath, const char* geometryFilePath = nullptr);
					It creates a shader from files.
					Shader LoadShader(const std::string& name, const char* vertexText, const char* fragmentText, const char* geometryText = nullptr);
					It creates a shader from strings.
					Shader GetShader(const std::string& name);
					It returns a shader. If the shader does not exist, it will return an uninitialized shader.
					It is recommended to use the IsShaderExist.
					bool IsShaderExist(const std::string& name);
					It returns true if the shader exist.
					void DestroyShader(const std::string& name);
					It destroys the shader.

					Texture2D LoadTextureFromFile(const std::string& name, const char* filePath, const Render::Texture2DSettings& settings);
					It creates a texture from files.
					Texture2D GetTexture(const std::string& name);
					It returns a texture. If the texture does not exist, it will return an uninitialized texture.
					It is recommended to use the IsTextureExist.
					bool IsTextureExist(const std::string& name);
					It returns true if the texture exist.
					void DestroyTexture2D(const std::string& name);
					It destroys the texture.
					
					void Clear();
					It destroys all shaders and textures.
			Singleton
				Source code: 
				Description:
				A base singleton abstarct class.
				It is recommended, that the constructor of inherited class is private or protected and
				The Singleton is a friend class.
				Functions:
					Public:
					static T& GetInstance();
					It returns the instance.
			Transform
				Source code: 
				Description:
				It contains the position the scale and the rotation. Every gameobject has a transform.
				Variables:
					Public:
					glm::vec2 position;
					glm::vec2 scale;
					float rotation;